# Requirements for the Systems-Informed Neural Network (SINN) Framework

## 1. Project Goal

To create a modular, reusable, and hierarchical Python framework for building, training, and validating Systems-Informed Neural Networks (SINNs). The framework should be capable of solving systems of Ordinary Differential Equations (ODEs) defined using a compositional, Odum-style approach, and should be able to assimilate sparse experimental data to refine its predictions. The ultimate goal is to use this framework for complex digital twin applications, such as design optimization of a Noria water wheel in a hydraulic flume.

---

## 2. Foundational Framework Requirements (Phase 1)

This section defines the requirements for the core, testable, and modular framework that serves as the foundation for all future work.

### Issue 2.1: Create a Decoupled Physics Library
- **User Story:** As a scientist, I need to define and verify the governing equations of a physical system in a pure, transparent way, completely separate from any machine learning code.
- **Acceptance Criteria:**
    1.  A `systems_library.py` module will be created.
    2.  System models (e.g., `TankSystem`) will be implemented as Python classes within this module.
    3.  Each system class must provide a `get_derivative` method that encodes its governing ODE(s).
    4.  Each system class must provide a simple, transparent numerical solver (e.g., `solve_euler`) that uses its own `get_derivative` method.
    5.  The module must include a self-contained test harness (`if __name__ == "__main__":`) that runs the numerical solver and plots its output to visually verify the correctness of the physics implementation.

### Issue 2.2: Implement a Generic Training Framework
- **User Story:** As a developer, I need a reusable engine that can train any compatible PINN architecture against any compatible loss function without modification.
- **Acceptance Criteria:**
    1.  A `pinn_framework.py` module will be created containing a generic `PINN_Framework` class.
    2.  The framework will handle all boilerplate code: parameter initialization, optimizer setup, the training loop, and JIT compilation.
    3.  The `.train()` method must correctly handle both dynamic (batch-based) and static (problem-defining) arguments for the loss function.
    4.  The framework must include methods to `.save_snapshot()` and `.load_snapshot()` for model persistence.

### Issue 2.3: Implement a Test-Driven Application Workflow
- **User Story:** As a user, I need a clear script that demonstrates how to use the framework to solve a specific problem and validate the result.
- **Acceptance Criteria:**
    1.  A `train_and_validate.py` (or similarly named) script will serve as the main application entry point.
    2.  This script will import the `TankSystem` from the library and the `PINN_Framework` from its module.
    3.  It will define the PINN-specific components (the Flax `nn.Module` and the JAX-based loss function). The loss function **must** call the `get_derivative` method from the imported `TankSystem` instance.
    4.  After training, the script must generate and save quantitative diagnostics (e.g., `training_history.csv`, `inference_data.csv`).
    5.  The script must generate and save all necessary plots for validation and reporting (e.g., `loss_curve.png`, `final_comparison.png`).

### Issue 2.4: Implement Automated Reporting
- **User Story:** As a researcher, I need a script that automatically generates a professional, human-readable report summarizing the entire experiment.
- **Acceptance Criteria:**
    1.  A `generate_report.py` script will be created.
    2.  This script will read the `.csv` and `.png` files generated by the training script.
    3.  It will produce a `.tex` file containing a full report with sections for introduction, model definition, training diagnostics (including tables and plots), and inference results (including tables and plots).

---

## 3. Hierarchical & Multi-Scale Requirements (Phase 2)

### Issue 3.1: Implement Hierarchical System Composition
- **User Story:** As a systems modeler, I want to define a `SystemModel` that can contain other `SystemModel` instances as its components, so that I can represent multi-scale hierarchies.
- **Acceptance Criteria:**
    1.  The `SystemModel` class in `systems_library.py` must be able to accept other `SystemModel` objects in its `components` list.
    2.  The `get_derivative` or a new `get_residuals` method on a parent `SystemModel` must recursively call the corresponding methods on its child components and correctly sum the results.

### Issue 3.2: Generalize the PINN Architecture and Loss Function Factories
- **User Story:** As a developer, I want a `pinn_builder.py` module that can automatically generate the necessary Flax and JAX components by inspecting a hierarchical `SystemModel`.
- **Acceptance Criteria:**
    1.  The `build_pinn_model` function must create a multi-input, multi-output Flax `nn.Module` that matches the states and parameters of the entire system hierarchy.
    2.  The `build_loss_function` must traverse the system hierarchy and construct a single, composite loss function from all physics residuals.

---

## 4. Data Assimilation Requirements (Phase 3)

### Issue 4.1: Integrate Observational Data into the Loss Function
- **User Story:** As a researcher, I want to provide a dataset of real-world measurements to the training process to refine the SINN's accuracy.
- **Acceptance Criteria:**
    1.  The `PINN_Framework`'s `.train()` method must accept an optional `data` argument.
    2.  The loss function builder must be updated to include a weighted `Loss_Data` term that calculates the error against these observations.

---

## 5. Application and Optimization Requirements (Phase 4)

### Issue 5.1: Implement the Noria System Model
- **User Story:** As a user, I want to model the Flume+Noria system to test the Maximum Power Principle.
- **Acceptance Criteria:**
    1.  Create a new `NoriaSystem` class in `systems_library.py` that defines the coupled physics of the flume and the water wheel, including the backwater effect.

### Issue 5.2: Create a Gradient-Based Optimization Script
- **User Story:** As a designer, after training a parametric Noria SINN, I want to find the optimal `arc_length` that maximizes power output without an external optimization loop.
- **Acceptance Criteria:**
    1.  Create a new script, `optimize_design.py`.
    2.  It will load a pre-trained Noria SINN snapshot.
    3.  It will use `jax.grad` to find the optimal design parameter by maximizing the power output predicted by the SINN.